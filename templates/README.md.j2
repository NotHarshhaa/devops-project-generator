# ğŸš€ {{ project_name }}

A production-ready DevOps project generated by [DevOps Project Generator](https://github.com/NotHarshhaa/devops-project-generator).

## ğŸ“‹ Overview

This project demonstrates best practices for modern DevOps workflows, including:

- **CI/CD**: {{ ci | default('None') }}
- **Infrastructure**: {{ infra | default('None') }}
- **Deployment**: {{ deploy | default('None') }}
- **Observability**: {{ observability | default('Basic') }}
- **Security**: {{ security | default('Basic') }}

## ğŸ—ï¸ Project Structure

```
{{ project_name }}/
â”œâ”€â”€ app/
â”‚   â””â”€â”€ sample-app/          # Sample application
â”‚       â”œâ”€â”€ main.py
â”‚       â””â”€â”€ requirements.txt
â”œâ”€â”€ ci/
â”‚   â”œâ”€â”€ pipelines/           # CI/CD pipeline configurations
â”‚   â””â”€â”€ README.md
â”œâ”€â”€ infra/
â”‚   â”œâ”€â”€ {{ infra }}/         # Infrastructure as Code
â”‚   â””â”€â”€ environments/
â”œâ”€â”€ containers/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ docker-compose.yml
â”œâ”€â”€ k8s/
â”‚   â”œâ”€â”€ base/               # Kubernetes base manifests
â”‚   â””â”€â”€ overlays/           # Environment-specific overlays
â”œâ”€â”€ monitoring/
â”‚   â”œâ”€â”€ logs/               # Logging configuration
â”‚   â”œâ”€â”€ metrics/            # Metrics configuration
â”‚   â””â”€â”€ alerts/             # Alerting rules
â”œâ”€â”€ security/
â”‚   â”œâ”€â”€ secrets/            # Secret management
â”‚   â””â”€â”€ scanning/           # Security scanning
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ automation/         # Automation scripts
â”‚   â”œâ”€â”€ setup.sh
â”‚   â””â”€â”€ deploy.sh
â”œâ”€â”€ Makefile
â””â”€â”€ README.md
```

## ğŸš€ Quick Start

### Prerequisites

- Python 3.9+
- Docker & Docker Compose
{% if has_kubernetes %}
- kubectl
{% endif %}
{% if has_infra and infra == 'terraform' %}
- Terraform
{% endif %}

### Installation

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd {{ project_name }}
   ```

2. **Setup the environment**
   ```bash
   make setup
   ```

3. **Start the application**
   ```bash
   make start
   ```

4. **Verify the deployment**
   ```bash
   make health
   ```

## ğŸ“– Available Commands

### Development Commands

```bash
# Setup development environment
make dev-setup

# Run in development mode
make dev-run

# Run tests
make test

# Run linting
make lint

# Format code
make format
```

### Deployment Commands

```bash
# Deploy application
make deploy

# Rollback deployment
make rollback

# Check deployment status
make k8s-status  # Kubernetes only
```

### Infrastructure Commands

{% if has_infra and infra == 'terraform' %}
```bash
# Initialize Terraform
make tf-init

# Plan infrastructure changes
make tf-plan

# Apply infrastructure changes
make tf-apply
```
{% endif %}

### Monitoring Commands

```bash
# Check application health
make health

# Check application readiness
make ready

# View logs
make logs

{% if has_metrics %}
# View metrics
make metrics
{% endif %}
```

## ğŸ”§ Configuration

### Environment Variables

The application uses environment variables for configuration. See `.env` file for available options:

```bash
# Application
ENV=production
DEBUG=false
PORT=8000
LOG_LEVEL=INFO

# Database
DATABASE_URL=postgresql://user:pass@localhost:5432/{{ project_name }}
REDIS_URL=redis://localhost:6379/0

# Security
JWT_SECRET=your-jwt-secret
SECRET_KEY=your-secret-key
API_KEY=your-api-key
```

### Environment-Specific Configuration

{% if is_multi_env %}
This project supports multiple environments:

- **Development**: For local development
- **Staging**: For pre-production testing
- **Production**: For production deployment

Each environment has its own configuration and deployment settings.
{% else %}
This project uses a single environment configuration.
{% endif %}

## ğŸ”„ CI/CD Pipeline

### Pipeline Stages

1. **Test**: Unit tests, linting, and code quality checks
2. {% if has_docker %}**Build**: Docker image building and pushing{% endif %}
3. {% if has_kubernetes %}**Deploy**: Kubernetes deployment{% endif %}
4. {% if has_infra %}**Infrastructure**: Infrastructure provisioning{% endif %}

### Pipeline Configuration

{% if ci == 'github-actions' %}
- **Platform**: GitHub Actions
- **Configuration**: `.github/workflows/ci.yml`
- **Triggers**: Push to main/develop, pull requests
{% elif ci == 'gitlab-ci' %}
- **Platform**: GitLab CI
- **Configuration**: `.gitlab-ci.yml`
- **Triggers**: Push to main/develop
{% elif ci == 'jenkins' %}
- **Platform**: Jenkins
- **Configuration**: `Jenkinsfile`
- **Triggers**: Webhook or manual
{% endif %}

## ğŸ—ï¸ Infrastructure

{% if has_infra %}
### Infrastructure as Code

This project uses **{{ infra }}** for infrastructure management:

{% if infra == 'terraform' %}
- **Provider**: AWS
- **Services**: VPC, EC2, RDS, S3, CloudWatch
- **Configuration**: `infra/terraform/`
{% elif infra == 'cloudformation' %}
- **Provider**: AWS CloudFormation
- **Services**: VPC, EC2, RDS, S3, CloudWatch
- **Configuration**: `infra/cloudformation/`
{% endif %}

### Infrastructure Components

- **Networking**: VPC with public and private subnets
- **Compute**: {% if deploy == 'kubernetes' %}EKS Cluster{% elif deploy == 'docker' %}EC2 instances{% else %}VM instances{% endif %}
- **Database**: PostgreSQL with automated backups
- **Storage**: S3 bucket for application data
- **Monitoring**: CloudWatch metrics and logs

### Environment Management

{% if is_multi_env %}
Each environment has its own infrastructure configuration:
- `infra/environments/dev.tf`
- `infra/environments/staging.tf`
- `infra/environments/prod.tf`
{% endif %}
{% else %}
No infrastructure automation is configured. Manual setup required.
{% endif %}

## ğŸš€ Deployment

### Deployment Strategy

{% if deploy == 'kubernetes' %}
#### Kubernetes Deployment

This project uses Kubernetes for container orchestration:

- **Base Resources**: `k8s/base/`
- **Environment Overlays**: `k8s/overlays/`
- **Deployment Method**: Rolling updates with health checks

**Deployment Steps:**
```bash
# Deploy to Kubernetes
make k8s-deploy

# Check deployment status
make k8s-status

# View logs
make k8s-logs
```

{% elif deploy == 'docker' %}
#### Docker Deployment

This project uses Docker for containerization:

- **Containerization**: Multi-stage Docker builds
- **Orchestration**: Docker Compose
- **Service Management**: Automated restarts and health checks

**Deployment Steps:**
```bash
# Build Docker image
make build

# Run with Docker Compose
make docker-run

# View logs
make docker-logs
```

{% else %}
#### VM Deployment

This project uses traditional VM deployment:

- **Provisioning**: Automated setup scripts
- **Configuration**: Environment-specific settings
- **Service Management**: Systemd services

**Deployment Steps:**
```bash
# Run deployment script
./scripts/deploy.sh deploy

# Check service status
systemctl status {{ project_name }}
```
{% endif %}

### Deployment Environments

{% if is_multi_env %}
- **Development**: `dev.{{ project_name }}.com`
- **Staging**: `staging.{{ project_name }}.com`
- **Production**: `{{ project_name }}.com`
{% else %}
- **Production**: `{{ project_name }}.com`
{% endif %}

## ğŸ“Š Monitoring & Observability

### Logging

{% if observability == 'logs' %}
- **Level**: Basic logging
- **Format**: Structured JSON
- **Storage**: Local files
{% elif observability == 'logs-metrics' %}
- **Level**: Logs + Metrics
- **Format**: Structured JSON with metrics
- **Storage**: ELK Stack + Prometheus
{% else %}
- **Level**: Full observability
- **Format**: Structured JSON with metrics and traces
- **Storage**: ELK Stack + Prometheus + Jaeger
{% endif %}

### Metrics

{% if has_metrics %}
- **Collection**: Prometheus
- **Visualization**: Grafana
- **Alerting**: AlertManager
- **Key Metrics**:
  - Application performance
  - Infrastructure metrics
  - Business metrics
{% endif %}

### Health Checks

The application provides multiple health endpoints:

- **Health Check**: `/health` - Basic application health
- **Readiness Check**: `/ready` - Application readiness
- **Metrics**: `/metrics` - Prometheus metrics
- **Info**: `/info` - Application information

### Alerting

{% if has_alerts %}
- **AlertManager**: Configured for critical alerts
- **Channels**: Email, Slack (configurable)
- **Alert Types**:
  - Application downtime
  - High error rates
  - Performance degradation
  - Infrastructure issues
{% endif %}

## ğŸ”’ Security

### Security Measures

This project implements **{{ security }}** security measures:

{% if security == 'basic' %}
- **Authentication**: Basic JWT authentication
- **Authorization**: Simple role-based access
- **Data Protection**: Basic encryption
- **Compliance**: Minimal security standards
{% elif security == 'standard' %}
- **Authentication**: Multi-factor authentication
- **Authorization**: Role-based access control (RBAC)
- **Data Protection**: Encryption at rest and in transit
- **Network Security**: Network policies and firewalls
- **Compliance**: Industry standard compliance
{% else %}
- **Authentication**: Multi-factor authentication with SSO
- **Authorization**: Attribute-based access control (ABAC)
- **Data Protection**: Advanced encryption with key rotation
- **Network Security**: Zero-trust network architecture
- **Compliance**: Enterprise-grade compliance (SOC2, ISO27001, GDPR)
{% endif %}

### Security Scanning

- **Static Analysis**: Bandit, Semgrep
- **Dependency Scanning**: Safety, pip-audit
- **Container Scanning**: Trivy, Grype
- **Infrastructure Scanning**: tfsec, Checkov
- **Secrets Scanning**: GitLeaks, TruffleHog

### Security Best Practices

- **Least Privilege**: Minimal permissions for all services
- **Secret Management**: Encrypted secrets with rotation
- **Network Segmentation**: Isolated network zones
- **Audit Logging**: Comprehensive audit trails
- **Regular Updates**: Automated security updates

## ğŸ§ª Testing

### Test Types

- **Unit Tests**: pytest with coverage
- **Integration Tests**: API and database integration
- **Security Tests**: Security scanning and penetration testing
- **Performance Tests**: Load testing and performance profiling

### Running Tests

```bash
# Run all tests
make test

# Run tests with coverage
make test-coverage

# Run tests in watch mode
make test-watch

# Run performance tests
make perf-test
```

### Test Coverage

- **Target Coverage**: 80% minimum
- **Coverage Report**: HTML and terminal output
- **CI Integration**: Automated coverage checks

## ğŸ› ï¸ Development

### Local Development

1. **Setup environment**
   ```bash
   make dev-setup
   ```

2. **Run in development mode**
   ```bash
   make dev-run
   ```

3. **Make changes and test**
   ```bash
   make test
   make lint
   ```

### Code Quality

- **Linting**: flake8 with strict rules
- **Formatting**: black with consistent style
- **Type Checking**: mypy for static analysis
- **Pre-commit Hooks**: Automated quality checks

### Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Run tests and quality checks
5. Submit a pull request

## ğŸ“š Documentation

### API Documentation

- **Swagger/OpenAPI**: Available at `/docs`
- **API Reference**: Complete API documentation
- **Examples**: Usage examples and tutorials

### Architecture Documentation

- **System Architecture**: High-level architecture overview
- **Data Flow**: Data flow diagrams
- **Security Architecture**: Security design and controls

### Operational Documentation

- **Runbook**: Incident response procedures
- **Troubleshooting**: Common issues and solutions
- **Maintenance**: Regular maintenance procedures

## ğŸš¨ Troubleshooting

### Common Issues

1. **Application won't start**
   - Check environment variables
   - Verify database connectivity
   - Review application logs

2. **Health check fails**
   - Check service status
   - Verify port availability
   - Review resource usage

3. **Deployment fails**
   - Check infrastructure status
   - Verify configuration files
   - Review deployment logs

### Getting Help

- **Logs**: `make logs`
- **Health Check**: `make health`
- **Status**: `make info`
- **Documentation**: Check the `/docs` endpoint

## ğŸ“ˆ Performance

### Performance Monitoring

- **Response Time**: < 200ms (95th percentile)
- **Throughput**: 1000+ requests/second
- **Error Rate**: < 0.1%
- **Uptime**: 99.9%+

### Optimization

- **Database**: Connection pooling and indexing
- **Caching**: Redis for frequently accessed data
- **CDN**: Static content delivery
- **Load Balancing**: Horizontal scaling

## ğŸ”„ Version Management

### Versioning Strategy

- **Semantic Versioning**: MAJOR.MINOR.PATCH
- **Release Branches**: Stable release branches
- **Tagging**: Automated release tags
- **Changelog**: Comprehensive change log

### Release Process

1. Update version numbers
2. Run full test suite
3. Create release tag
4. Deploy to staging
5. Run integration tests
6. Deploy to production

## ğŸ“ Support

### Getting Help

- **Documentation**: This README and inline docs
- **Issues**: GitHub Issues for bug reports
- **Discussions**: GitHub Discussions for questions
- **Email**: devops@{{ project_name }}.com

### Emergency Contacts

- **DevOps Team**: devops-alerts@{{ project_name }}.com
- **Security Team**: security@{{ project_name }}.com
- **On-call Engineer**: oncall@{{ project_name }}.com

## ğŸ“„ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ğŸ™ Acknowledgments

- **DevOps Project Generator**: For the project scaffolding
- **Open Source Community**: For the amazing tools and libraries
- **Security Team**: For security best practices
- **Operations Team**: For operational excellence

---

**Generated by DevOps Project Generator**  
*Build better DevOps projects, faster.*
