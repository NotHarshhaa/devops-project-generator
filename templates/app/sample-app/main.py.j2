#!/usr/bin/env python3
"""
Sample Application for {{ project_name }}
Generated by DevOps Project Generator
"""

import os
import logging
import json
from datetime import datetime
from typing import Dict, Any

{% if has_metrics %}
from prometheus_client import Counter, Histogram, Gauge, generate_latest, CONTENT_TYPE_LATEST
from prometheus_client import start_http_server
{% endif %}

# Configuration
class Config:
    def __init__(self):
        self.env = os.getenv('ENV', 'production')
        self.debug = os.getenv('DEBUG', 'false').lower() == 'true'
        self.port = int(os.getenv('PORT', 8000))
        self.log_level = os.getenv('LOG_LEVEL', 'INFO')
        self.database_url = os.getenv('DATABASE_URL', 'sqlite:///app.db')
        self.redis_url = os.getenv('REDIS_URL', 'redis://localhost:6379/0')
        
        # Setup logging
        self.setup_logging()
    
    def setup_logging(self):
        """Setup structured logging"""
        log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        
        if self.env == 'production':
            logging.basicConfig(
                level=getattr(logging, self.log_level),
                format=log_format,
                handlers=[
                    logging.StreamHandler(),
                    logging.FileHandler('/app/logs/app.log')
                ]
            )
        else:
            logging.basicConfig(
                level=logging(logging.DEBUG if self.debug else self.log_level),
                format=log_format
            )
        
        self.logger = logging.getLogger(__name__)

# Metrics
{% if has_metrics %}
REQUEST_COUNT = Counter('http_requests_total', 'Total HTTP requests', ['method', 'endpoint', 'status'])
REQUEST_DURATION = Histogram('http_request_duration_seconds', 'HTTP request duration')
ACTIVE_CONNECTIONS = Gauge('active_connections', 'Active connections')
{% endif %}

class SampleApp:
    def __init__(self):
        self.config = Config()
        self.logger = self.config.logger
        self.start_time = datetime.now()
        
        {% if has_metrics %}
        # Start metrics server
        start_http_server(9090)
        self.logger.info("Metrics server started on port 9090")
        {% endif %}
    
    {% if has_health_checks %}
    def health_check(self) -> Dict[str, Any]:
        """Health check endpoint"""
        return {
            "status": "healthy",
            "timestamp": datetime.now().isoformat(),
            "version": "1.0.0",
            "environment": self.config.env,
            "uptime_seconds": (datetime.now() - self.start_time).total_seconds()
        }
    
    def readiness_check(self) -> Dict[str, Any]:
        """Readiness check endpoint"""
        # Check database connectivity
        db_healthy = self.check_database()
        
        # Check Redis connectivity
        redis_healthy = self.check_redis()
        
        return {
            "status": "ready" if db_healthy and redis_healthy else "not_ready",
            "timestamp": datetime.now().isoformat(),
            "checks": {
                "database": db_healthy,
                "redis": redis_healthy
            }
        }
    {% endif %}
    
    def check_database(self) -> bool:
        """Check database connectivity"""
        try:
            # Simple database connectivity check
            # In a real app, you would check actual database connection
            return True
        except Exception as e:
            self.logger.error(f"Database check failed: {e}")
            return False
    
    def check_redis(self) -> bool:
        """Check Redis connectivity"""
        try:
            # Simple Redis connectivity check
            # In a real app, you would check actual Redis connection
            return True
        except Exception as e:
            self.logger.error(f"Redis check failed: {e}")
            return False
    
    {% if has_metrics %}
    def get_metrics(self) -> str:
        """Get Prometheus metrics"""
        return generate_latest()
    {% endif %}
    
    def get_info(self) -> Dict[str, Any]:
        """Application info endpoint"""
        return {
            "name": "{{ project_name }}",
            "version": "1.0.0",
            "environment": self.config.env,
            "description": "Sample application generated by DevOps Project Generator",
            "features": {
                "ci_cd": "{{ ci }}" if {{ ci }} else "none",
                "infrastructure": "{{ infra }}" if {{ infra }} else "none",
                "deployment": "{{ deploy }}" if {{ deploy }} else "none",
                "observability": "{{ observability }}" if {{ observability }} else "basic",
                "security": "{{ security }}" if {{ security }} else "basic"
            },
            "endpoints": {
                {% if has_health_checks %}
                "health": "/health",
                "ready": "/ready",
                {% endif %}
                {% if has_metrics %}
                "metrics": "/metrics",
                {% endif %}
                "info": "/info"
            }
        }
    
    def handle_request(self, method: str, path: str) -> Dict[str, Any]:
        """Handle HTTP requests"""
        {% if has_metrics %}
        with REQUEST_DURATION.time():
            ACTIVE_CONNECTIONS.inc()
            try:
                if path == "/health":
                    response = self.health_check()
                    status = "200"
                elif path == "/ready":
                    response = self.readiness_check()
                    status = "200"
                elif path == "/metrics":
                    response = self.get_metrics()
                    status = "200"
                elif path == "/info":
                    response = self.get_info()
                    status = "200"
                else:
                    response = {"error": "Not found"}
                    status = "404"
                
                REQUEST_COUNT.labels(method=method, endpoint=path, status=status).inc()
                return response, status
            finally:
                ACTIVE_CONNECTIONS.dec()
        {% else %}
        if path == "/health":
            return self.health_check(), "200"
        elif path == "/ready":
            return self.readiness_check(), "200"
        elif path == "/info":
            return self.get_info(), "200"
        else:
            return {"error": "Not found"}, "404"
        {% endif %}

def main():
    """Main application entry point"""
    app = SampleApp()
    
    # Log startup
    app.logger.info(f"Starting {{ project_name }} application")
    app.logger.info(f"Environment: {app.config.env}")
    app.logger.info(f"Port: {app.config.port}")
    
    # Create logs directory if it doesn't exist
    os.makedirs('/app/logs', exist_ok=True)
    
    # Simple HTTP server simulation
    import http.server
    import socketserver
    from urllib.parse import urlparse
    
    class AppHandler(http.server.BaseHTTPRequestHandler):
        def do_GET(self):
            app = SampleApp()
            path = urlparse(self.path).path
            
            try:
                response, status = app.handle_request("GET", path)
                
                if path == "/metrics":
                    self.send_response(200)
                    self.send_header('Content-Type', CONTENT_TYPE_LATEST)
                    self.end_headers()
                    self.wfile.write(response.encode())
                else:
                    self.send_response(int(status))
                    self.send_header('Content-Type', 'application/json')
                    self.end_headers()
                    self.wfile.write(json.dumps(response, indent=2).encode())
                    
            except Exception as e:
                app.logger.error(f"Request failed: {e}")
                self.send_response(500)
                self.send_header('Content-Type', 'application/json')
                self.end_headers()
                self.wfile.write(json.dumps({"error": "Internal server error"}).encode())
        
        def log_message(self, format, *args):
            """Override to use our logger"""
            app.logger.info(format % args)
    
    # Start server
    with socketserver.TCPServer(("", app.config.port), AppHandler) as httpd:
        app.logger.info(f"Server running on port {app.config.port}")
        try:
            httpd.serve_forever()
        except KeyboardInterrupt:
            app.logger.info("Server stopped by user")
            httpd.shutdown()

if __name__ == "__main__":
    main()
