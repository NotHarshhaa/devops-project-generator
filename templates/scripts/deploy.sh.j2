#!/bin/bash

# Deployment Script for {{ project_name }}
# Generated by DevOps Project Generator

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
PROJECT_NAME="{{ project_name }}"
ENVIRONMENT="{{ env | default('production') }}"
DEPLOYMENT_METHOD="{{ deploy }}"
INFRASTRUCTURE="{{ infra }}"

# Logging function
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $1${NC}"
    exit 1
}

warning() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING: $1${NC}"
}

info() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')] INFO: $1${NC}"
}

# Check deployment prerequisites
check_prerequisites() {
    log "Checking deployment prerequisites..."
    
    case $DEPLOYMENT_METHOD in
        "docker")
            if ! command -v docker &> /dev/null; then
                error "Docker is required but not installed"
            fi
            if ! command -v docker-compose &> /dev/null; then
                error "Docker Compose is required but not installed"
            fi
            ;;
        "kubernetes")
            if ! command -v kubectl &> /dev/null; then
                error "kubectl is required but not installed"
            fi
            ;;
        "vm")
            if ! command -v ssh &> /dev/null; then
                error "SSH is required but not installed"
            fi
            ;;
    esac
    
    log "Prerequisites check passed"
}

# Deploy with Docker
deploy_docker() {
    log "Deploying with Docker..."
    
    # Build Docker image
    docker build -t ${PROJECT_NAME}:latest ./containers/
    
    # Tag image for deployment
    docker tag ${PROJECT_NAME}:latest ${PROJECT_NAME}:${ENVIRONMENT}
    
    {% if env == 'production' %}
    # Push to registry (configure your registry)
    # docker push ${PROJECT_NAME}:latest
    # docker push ${PROJECT_NAME}:${ENVIRONMENT}
    {% endif %}
    
    # Deploy with docker-compose
    docker-compose -f containers/docker-compose.yml up -d
    
    # Wait for services to be ready
    log "Waiting for services to be ready..."
    sleep 30
    
    # Health check
    if curl -f http://localhost:8000/health > /dev/null 2>&1; then
        log "Docker deployment successful"
    else
        error "Docker deployment failed - health check failed"
    fi
}

# Deploy with Kubernetes
deploy_kubernetes() {
    log "Deploying with Kubernetes..."
    
    # Set namespace
    kubectl create namespace ${PROJECT_NAME}-${ENVIRONMENT} --dry-run=client -o yaml | kubectl apply -f -
    
    # Apply base configurations
    kubectl apply -f k8s/base/ --namespace ${PROJECT_NAME}-${ENVIRONMENT}
    
    # Apply environment-specific overlays
    if [[ -d "k8s/overlays/${ENVIRONMENT}" ]]; then
        kubectl apply -k k8s/overlays/${ENVIRONMENT}/ --namespace ${PROJECT_NAME}-${ENVIRONMENT}
    else
        kubectl apply -k k8s/overlays/production/ --namespace ${PROJECT_NAME}-${ENVIRONMENT}
    fi
    
    # Wait for deployment to be ready
    log "Waiting for deployment to be ready..."
    kubectl rollout status deployment/${PROJECT_NAME} --namespace ${PROJECT_NAME}-${ENVIRONMENT} --timeout=300s
    
    # Get service URL
    SERVICE_URL=$(kubectl get service ${PROJECT_NAME} --namespace ${PROJECT_NAME}-${ENVIRONMENT} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "localhost")
    
    # Health check
    sleep 10
    if kubectl get pods --namespace ${PROJECT_NAME}-${ENVIRONMENT} -l app=${PROJECT_NAME} | grep Running > /dev/null; then
        log "Kubernetes deployment successful"
        info "Service URL: ${SERVICE_URL}"
    else
        error "Kubernetes deployment failed - pods not ready"
    fi
}

# Deploy to VM
deploy_vm() {
    log "Deploying to VM..."
    
    # Configuration (update these with your actual VM details)
    VM_USER="deploy"
    VM_HOST="${VM_HOST:-localhost}"
    VM_SSH_KEY="${VM_SSH_KEY:-~/.ssh/id_rsa}"
    
    # Copy files to VM
    info "Copying files to VM..."
    scp -i ${VM_SSH_KEY} -r . ${VM_USER}@${VM_HOST}:/opt/${PROJECT_NAME}/
    
    # Execute deployment script on VM
    info "Executing deployment script on VM..."
    ssh -i ${VM_SSH_KEY} ${VM_USER}@${VM_HOST} "cd /opt/${PROJECT_NAME} && chmod +x scripts/vm-deploy.sh && ./scripts/vm-deploy.sh"
    
    # Health check
    if curl -f http://${VM_HOST}/health > /dev/null 2>&1; then
        log "VM deployment successful"
    else
        error "VM deployment failed - health check failed"
    fi
}

# Deploy infrastructure
deploy_infrastructure() {
    if [[ -n "$INFRASTRUCTURE" && "$INFRASTRUCTURE" != "none" ]]; then
        log "Deploying infrastructure with ${INFRASTRUCTURE}..."
        
        case $INFRASTRUCTURE in
            "terraform")
                cd infra/terraform
                terraform init
                terraform plan -out=tfplan
                terraform apply -auto-approve tfplan
                cd ../..
                ;;
            "cloudformation")
                # Deploy CloudFormation stack
                aws cloudformation deploy \
                    --template-file infra/cloudformation/template.yml \
                    --stack-name ${PROJECT_NAME}-${ENVIRONMENT} \
                    --parameter-overrides ProjectName=${PROJECT_NAME} Environment=${ENVIRONMENT} \
                    --capabilities CAPABILITY_IAM
                ;;
        esac
        
        log "Infrastructure deployment completed"
    fi
}

# Run pre-deployment tests
run_pre_deployment_tests() {
    log "Running pre-deployment tests..."
    
    # Activate virtual environment
    source venv/bin/activate
    
    # Run tests
    if command -v pytest &> /dev/null; then
        pytest app/sample-app/ --cov=app/sample-app --cov-fail-under=80
        log "Pre-deployment tests passed"
    else
        warning "pytest not found. Skipping tests"
    fi
}

# Run post-deployment tests
run_post_deployment_tests() {
    log "Running post-deployment tests..."
    
    # Health check
    {% if has_health_checks %}
    if curl -f http://localhost:8000/health > /dev/null 2>&1; then
        log "Health check passed"
    else
        error "Health check failed"
    fi
    {% endif %}
    
    # Readiness check
    {% if has_health_checks %}
    if curl -f http://localhost:8000/ready > /dev/null 2>&1; then
        log "Readiness check passed"
    else
        warning "Readiness check failed"
    fi
    {% endif %}
    
    # Application info check
    if curl -f http://localhost:8000/info > /dev/null 2>&1; then
        log "Application info check passed"
    else
        warning "Application info check failed"
    fi
}

# Backup current deployment
backup_deployment() {
    log "Backing up current deployment..."
    
    # Create backup directory
    BACKUP_DIR="backups/$(date +%Y%m%d_%H%M%S)"
    mkdir -p ${BACKUP_DIR}
    
    # Backup configuration files
    cp -r .env ${BACKUP_DIR}/ 2>/dev/null || true
    cp -r k8s/ ${BACKUP_DIR}/ 2>/dev/null || true
    cp -r containers/ ${BACKUP_DIR}/ 2>/dev/null || true
    
    log "Backup completed: ${BACKUP_DIR}"
}

# Rollback deployment
rollback_deployment() {
    log "Rolling back deployment..."
    
    # Find latest backup
    LATEST_BACKUP=$(ls -t backups/ | head -1)
    
    if [[ -n "$LATEST_BACKUP" ]]; then
        log "Rolling back to backup: ${LATEST_BACKUP}"
        
        # Restore from backup
        cp backups/${LATEST_BACKUP}/.env . 2>/dev/null || true
        cp -r backups/${LATEST_BACKUP}/k8s/ . 2>/dev/null || true
        cp -r backups/${LATEST_BACKUP}/containers/ . 2>/dev/null || true
        
        # Re-deploy
        main
    else
        error "No backup found for rollback"
    fi
}

# Update configuration
update_configuration() {
    log "Updating configuration..."
    
    # Update environment variables
    cat > .env << EOF
# Updated deployment configuration
ENV=${ENVIRONMENT}
DEPLOYMENT_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
VERSION=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")

# Database Configuration
DATABASE_URL=postgresql://postgres:password@localhost:5432/${PROJECT_NAME}
REDIS_URL=redis://localhost:6379/0

# Security
JWT_SECRET=updated-jwt-secret-$(date +%s)
SECRET_KEY=updated-secret-key-$(date +%s)
EOF
    
    log "Configuration updated"
}

# Cleanup old resources
cleanup_resources() {
    log "Cleaning up old resources..."
    
    {% if deploy == 'docker' %}
    # Remove old Docker images
    docker image prune -f
    {% endif %}
    
    {% if deploy == 'kubernetes' %}
    # Remove old Kubernetes resources
    kubectl delete pods --field-selector=status.phase=Succeeded --namespace ${PROJECT_NAME}-${ENVIRONMENT} --ignore-not-found=true
    {% endif %}
    
    # Remove old backups (keep last 5)
    ls -t backups/ | tail -n +6 | xargs -I {} rm -rf backups/{} 2>/dev/null || true
    
    log "Cleanup completed"
}

# Main deployment function
main() {
    log "Starting deployment of ${PROJECT_NAME} to ${ENVIRONMENT}..."
    log "Deployment method: ${DEPLOYMENT_METHOD}"
    
    # Parse command line arguments
    case "${1:-deploy}" in
        "deploy")
            check_prerequisites
            backup_deployment
            run_pre_deployment_tests
            update_configuration
            deploy_infrastructure
            deploy_${DEPLOYMENT_METHOD}
            run_post_deployment_tests
            cleanup_resources
            log "Deployment completed successfully!"
            ;;
        "rollback")
            rollback_deployment
            ;;
        "test")
            run_pre_deployment_tests
            run_post_deployment_tests
            ;;
        "cleanup")
            cleanup_resources
            ;;
        "help"|"-h"|"--help")
            echo "Usage: $0 [deploy|rollback|test|cleanup|help]"
            echo "  deploy    - Deploy the application (default)"
            echo "  rollback  - Rollback to previous deployment"
            echo "  test      - Run deployment tests"
            echo "  cleanup   - Clean up old resources"
            echo "  help      - Show this help message"
            exit 0
            ;;
        *)
            error "Unknown command: $1. Use 'help' for available commands."
            ;;
    esac
}

# Run main function
main "$@"
